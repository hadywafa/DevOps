## Service Accounts in Kubernetes

## What is a Service Account?

A Service Account in Kubernetes is a special type of account used by processes running inside pods to interact with the Kubernetes API. Unlike regular user accounts, which are used by humans, service accounts are intended for applications, controllers, or any other automated processes that need to access Kubernetes resources.

Service accounts provide a secure and managed way to grant specific permissions to these processes, ensuring they only have the access they need.

## Why Use Service Accounts?

- **Security**: Service accounts help enforce the principle of least privilege by assigning only the necessary permissions to the processes running in your pods.
- **Isolation**: Each service account can be isolated, ensuring that different applications or processes have distinct access levels.
- **Auditability**: Actions performed by service accounts are logged, making it easier to track and audit API interactions.

## How to Create a Service Account

Creating a service account in Kubernetes is straightforward. Hereâ€™s how you can do it:

### 1. **Create the Service Account**

A service account is used by processes within a pod to interact with the Kubernetes API. To create a service account:

- **Using `kubectl`**:

  ```bash
  kubectl create serviceaccount <service-account-name>
  ```

  Example:

  ```bash
  kubectl create serviceaccount my-service-account
  ```

#### Using a YAML Manifest

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-service-account
  namespace: default
```

#### Apply the manifest

```bash
kubectl apply -f serviceaccount.yaml
```

### 2. **Assign Permissions to the Service Account**

Once the service account is created, you need to assign permissions by binding it to a `Role` or `ClusterRole`. This is done using a `RoleBinding` or `ClusterRoleBinding`.

- **Create a Role or ClusterRole** (if not already existing):

  ```yaml
  apiVersion: rbac.authorization.k8s.io/v1
  kind: Role
  metadata:
    namespace: default
    name: pod-reader
  rules:
    - apiGroups: [""]
      resources: ["pods"]
      verbs: ["get", "list", "watch"]
  ```

#### Bind the Service Account to the Role

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods-binding
  namespace: default
subjects:
  - kind: ServiceAccount
    name: my-service-account
    namespace: default
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

#### Apply the manifest

```bash
kubectl apply -f rolebinding.yaml
```

### 3. **Use the Service Account in a Pod**

To use the service account in a pod, specify it in the pod's specification under `serviceAccountName`.

#### Pod Manifest Example

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  namespace: default
spec:
  serviceAccountName: my-service-account
  containers:
    - name: my-container
      image: nginx
```

#### Apply the manifest

```bash
kubectl apply -f pod.yaml
```

#### 4. **Access the Kubernetes API Using the Service Account**

When a pod uses a service account, Kubernetes automatically mounts a token into the pod at `/var/run/secrets/kubernetes.io/serviceaccount/token`. This token can be used to authenticate API requests.

#### Example of Accessing the API

```bash
curl --header "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" https://kubernetes.default.svc/api
```

## Best Practices

- **Limit Permissions**: Only grant the permissions necessary for the service account to perform its tasks. Avoid using broad permissions like `cluster-admin` unless absolutely necessary.
- **Namespace Isolation**: Use separate service accounts for different namespaces to maintain isolation.
- **Rotate Tokens**: Regularly rotate service account tokens to maintain security.

## Summary

Service accounts in Kubernetes provide a secure and manageable way for processes running in pods to interact with the Kubernetes API. By creating service accounts, binding them to specific roles, and using them in your pods, you can enforce fine-grained access control, ensuring that your applications have only the permissions they need. This enhances security, maintains isolation, and ensures that API interactions are auditable and traceable.
