# Users, Groups and Service Account in k8s

In Kubernetes, user and group management is typically handled externally and not directly managed by the Kubernetes API. This is because Kubernetes does not have a built-in user management system. Instead, it relies on external identity providers for authentication. Here’s how you can manage users and groups and integrate them with Kubernetes.

## Creating Users

To create users in Kubernetes, you typically use one of the following methods:

1. **Client Certificate Authentication**:

   - Generate a client certificate for each user.
   - Configure the Kubernetes API server to trust the Certificate Authority (CA) that issued the client certificates.

2. **Static Token File**:

   - Use a static token file to manage users.
   - Define tokens for each user in a file and configure the API server to use this file.

3. **External Identity Providers**:
   - Use external systems like LDAP, Active Directory, or OAuth2 to manage user authentication.
   - Integrate these systems with Kubernetes through an Identity Provider (IdP).

## Method 1: Client Certificate Authentication

1. **Generate and sign a client certificate** for the user "hady" using the existing Kubernetes CA.
2. **Base64 encode** the CA certificate, user certificate, and user key.
3. **Create a kubeconfig file** that embeds these Base64-encoded values.
4. **Distribute the kubeconfig file** to the user.
5. The **user configures `kubectl`** to use the provided kubeconfig file.

### **1. Generate a Client Certificate for the User "hady"**

1. **Locate the Existing CA Files**:

   - CA Certificate: `/etc/kubernetes/pki/ca.crt`
   - CA Key: `/etc/kubernetes/pki/ca.key`

2. **Generate a Private Key for the User**:

   ```sh
   openssl genrsa -out hady.key 2048
   ```

3. **Create a Certificate Signing Request (CSR) for the User**:

   ```sh
   openssl req -new -key hady.key -subj "/CN=hady/O=dev-group" -out hady.csr
   ```

   - **`/CN=hady`**: Common Name (username) in Kubernetes.
   - **`/O=dev-group`**: Organization (group) in Kubernetes.

4. **Sign the CSR with the Kubernetes CA**:

   ```sh
   openssl x509 -req -in hady.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out hady.crt -days 365
   ```

### **2. Base64 Encode the Necessary Files**

1. **Base64 Encode the CA Certificate**:

   ```sh
   cat /etc/kubernetes/pki/ca.crt | base64 | tr -d '\n' > ca.crt.base64
   ```

2. **Base64 Encode the User’s Certificate**:

   ```sh
   cat hady.crt | base64 | tr -d '\n' > hady.crt.base64
   ```

3. **Base64 Encode the User’s Private Key**:

   ```sh
   cat hady.key | base64 | tr -d '\n' > hady.key.base64
   ```

### **3. Create the kubeconfig File**

1. **Create the kubeconfig File** with the embedded certificates and key:

   ```yaml
   apiVersion: v1
   kind: Config
   clusters:
     - name: kubernetes-cluster
       cluster:
         server: https://<api-server-endpoint>:6443
         certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCg... # Replace with content of ca.crt.base64
   contexts:
     - name: hady-context
       context:
         cluster: kubernetes-cluster
         namespace: default
         user: hady
   current-context: hady-context
   users:
     - name: hady
       user:
         client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCg... # Replace with content of hady.crt.base64
         client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQo... # Replace with content of hady.key.base64
   ```

2. **Replace the placeholders**:
   - **`<api-server-endpoint>`**: Replace with your Kubernetes API server’s endpoint.
   - **`certificate-authority-data`**: Replace with the Base64-encoded CA certificate (`ca.crt.base64`).
   - **`client-certificate-data`**: Replace with the Base64-encoded user certificate (`hady.crt.base64`).
   - **`client-key-data`**: Replace with the Base64-encoded user key (`hady.key.base64`).

### **4. Distribute the kubeconfig File**

- **Send the kubeconfig File**: Send the complete kubeconfig file to the user "hady". Ensure that the file has proper permissions so that only the user can read it.

### **5. User Configures `kubectl`**

1. **Place the kubeconfig File**: The user should save the kubeconfig file to `~/.kube/config` or set the `KUBECONFIG` environment variable to point to the file.

2. **Set the Context** (if needed):

   ```sh
   kubectl config use-context hady-context
   ```

### 6. **if you want to extend your kubeconfig file**

```sh
kubectl config set-credentials username --client-certificate=user.crt --client-key=user.key
kubectl config set-context username-context --cluster=kubernetes-cluster --namespace=default --user=username
kubectl config use-context username-context
```

## Method 2: Static Token File

1. **Create a Token File**:

   ```sh
   echo "token,username,uid,groups" > token.csv
   echo "my-token,user1,uid1,group1" >> token.csv
   ```

2. **Configure the API Server**:
   Add the following flag to the API server startup arguments:

   ```sh
   --token-auth-file=/path/to/token.csv
   ```

## Method 3: External Identity Providers

Using an external identity provider is a robust way to manage users and groups. Here’s an example using OpenID Connect (OIDC):

- **External Identity Provider**: Define groups within the provider and assign users to these groups.

1. **Configure the OIDC Provider** (e.g., Keycloak, Auth0, Dex):

   - Set up an OIDC provider and create a client application for Kubernetes.

2. **Configure the Kubernetes API Server**:
   Add the following flags to the API server startup arguments:

   ```sh
   --oidc-issuer-url=https://issuer-url.com
   --oidc-client-id=kubernetes
   --oidc-username-claim=email
   --oidc-groups-claim=groups
   ```

## Summary

- **Users**: Managed externally (e.g., client certificates, static token files, external identity providers).
- **Groups**: Defined within client certificates or external identity providers.
- **RoleBindings and ClusterRoleBindings**: Used to assign permissions to users and groups within Kubernetes.

Once users and groups are set up, you can create RoleBindings and ClusterRoleBindings to manage permissions.
