# Minikube with Ingress

Complete Steps to Set Up Minikube with Ingress for Hosting Multiple Apps with a Single Server and Domain

In this guide, you will set up Minikube on a single server, expose multiple apps (e.g., a front-end and an API) using Ingress, and configure the server to route traffic based on hostnames. For this setup:

- The front-end app will be accessible at `hadywafa.com`.
- The API will be accessible at `api.hadywafa.com`.

## Prerequisites

1. **Server**: Ubuntu server with at least 4 GB of RAM.
2. **Public IP**: `81.10.0.7` (static IP for your server).
3. **Domain**: `hadywafa.com` (you have DNS control over this domain).
4. **Minikube Installed**: Use Minikube with the `none` driver (running directly on the host).
5. **Root or sudo access** on your server.

## Step 1: Install Minikube and Kubectl

### 1. **Update the server and install dependencies**

```bash
sudo apt update
sudo apt install curl apt-transport-https -y
```

### 2. **Install Minikube**

- Download and install Minikube:

  ```bash
  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  sudo install minikube-linux-amd64 /usr/local/bin/minikube
  ```

### 3. **Install Kubectl**

```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubectl
```

### 4. **Start Minikube** using the `none` driver

```bash
sudo minikube start --driver=none
```

This will start Minikube on the server without using a VM.

## Step 2: Enable Ingress in Minikube

### 1. **Enable the Ingress add-on** in Minikube

```bash
minikube addons enable ingress
```

### 2. **Verify that the Ingress controller is running**

```bash
kubectl get pods -n kube-system
```

Look for the `nginx-ingress-controller` pod running.

## Step 3: Expose Ingress Controller Using NodePort

Minikube’s Ingress controller is initially exposed only within the cluster (using `ClusterIP`). To allow external access, we will expose it using **NodePort**.

### 1. **Patch the Ingress controller service to use NodePort**

```bash
kubectl patch svc ingress-nginx-controller -n kube-system -p '{"spec": {"type": "NodePort"}}'
```

### 2. **Check the NodePort assigned to the Ingress controller**

```bash
kubectl get svc ingress-nginx-controller -n kube-system
```

Example output:

```bash
NAME                       TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx-controller   NodePort   10.105.203.19  <none>        80:32480/TCP,443:32443/TCP   3m
```

In this example:

- **NodePort 32480** will handle HTTP requests.
- **NodePort 32443** will handle HTTPS requests.

## Step 4: Deploy the Front-end and API Applications

### 1. **Create and deploy the front-end application**

Save the following as `frontend-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: nginx # Replace with your actual front-end image
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
```

Deploy the front-end app:

```bash
kubectl apply -f frontend-deployment.yaml
```

### 2. **Create and deploy the API application**

Save the following as `api-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
        - name: api
          image: nginx # Replace with your actual API image
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
```

Deploy the API app:

```bash
kubectl apply -f api-deployment.yaml
```

---

## Step 5: Configure Ingress for Host-based Routing

Now, we will configure Ingress to route traffic for different hostnames (`hadywafa.com` for the front-end and `api.hadywafa.com` for the API).

### 1. **Create the Ingress resource**

Save the following as `ingress.yaml`:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: hadywafa.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: frontend-service
                port:
                  number: 80
    - host: api.hadywafa.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: api-service
                port:
                  number: 80
```

### 2. **Apply the Ingress configuration**

```bash
kubectl apply -f ingress.yaml
```

### 3. **Verify the Ingress resource**

```bash
kubectl get ingress
```

You should see two hosts: `hadywafa.com` and `api.hadywafa.com` in the output.

## Step 6: Configure DNS and Router for External Access

### 1. **Configure DNS to point to your public IP**

You need to configure DNS records for `hadywafa.com` and `api.hadywafa.com` to point to your public IP (`81.10.0.7`).

- Create **A records** for both domains in your DNS provider’s control panel:
  - **hadywafa.com → 81.10.0.7**
  - **api.hadywafa.com → 81.10.0.7**

### 2. **Configure your router to forward traffic**

You will need to forward traffic from your public IP to the Minikube server using the NodePort.

1. **Forward HTTP (port 80) traffic** from `81.10.0.7` to the Ingress NodePort (e.g., `32480`).
2. **Forward HTTPS (port 443) traffic** from `81.10.0.7` to the Ingress NodePort (e.g., `32443`).

---

## Step 7: Test Your Setup

Once the DNS changes propagate and the router is configured, you can test the setup by accessing the front-end and API applications.

1. **Test the front-end** at `http://hadywafa.com`:

   ```bash
   curl http://hadywafa.com
   ```

2. **Test the API** at `http://api.hadywafa.com`:

   ```bash
   curl http://api.hadywafa.com
   ```

You should see the correct responses from the front-end and API services based on the hostname you use.

## Optional: Add HTTPS with Let’s Encrypt

To secure your domains with HTTPS, you can use **Let’s Encrypt**.

1. **Install Certbot**:

   ```bash
   sudo apt install certbot
   ```

2. **Obtain SSL certificates for your domains**:

   ```bash
   sudo certbot certonly --manual --preferred-challenges=dns -d hadywafa.com -d api.hadywafa.com
   ```

3. **Update the Ingress resource for TLS**:
   You will need to modify the Ingress resource to reference the SSL certificates. You can follow Minikube's documentation for detailed steps on adding TLS to Ingress.

## Summary

1. **Install Minikube** on your server and enable the **Ingress add-on**.
2. **Deploy your front-end and API applications** with services.
3. **Create an Ingress resource** to route traffic based on hostnames (`hadywafa.com` for front-end and `api.hadywafa.com` for the API).
4. **Forward traffic** from your router to the Minikube **Ingress NodePort**.
5. **Test the setup** using your domain names and optionally secure them with **Let’s Encrypt**.

This setup provides a simplified way to use Minikube with Ingress for routing traffic to multiple applications using domain-based routing.

Let me know if you need further help!
